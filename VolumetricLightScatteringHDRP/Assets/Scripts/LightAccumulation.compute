// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define M_PI 3.1415926535897932384626433832795

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture3D<float4> lightBufferTexture;

Texture2D<float4> LightDepth;
SamplerState samplerLightDepth;
float4 lightWS;

float4x4 vp;
float4x4 convertTo01;
StructuredBuffer<float4> points;
float4 Input_TexelSize;


//singleFroxel.z * (amount.x * amount.y) + singleFroxel.y * amount.x + singleFroxel.x
uint flat(uint3 id)
{
    return id.z * (Input_TexelSize.x * Input_TexelSize.y) + id.y * Input_TexelSize.x + id.x;
}

/*public static Vector3 WorldToProjectedLocal(Vector3 pWorld, Camera c, bool normalizedTo01, out bool isInside)
    {
        //Point from World to Box
        Matrix4x4 camP = c.projectionMatrix;
        Vector4 pWorld4 = pWorld.ToVector4();
        Matrix4x4 scaleMatrix = Matrix4x4.identity;
        scaleMatrix.m22 = -1.0f;
        Matrix4x4 v = scaleMatrix * c.transform.worldToLocalMatrix;
        Matrix4x4 vp = camP * v;
        //get point projected in localSpace
        Vector4 pointProjected = vp * pWorld4;
        //correct projection by depthfactor -> now in box
        pointProjected /= pointProjected.w;
        Color cResult;
        //!!!! Only z-Tested !!!!
        isInside = (pointProjected.z <= 1 && pointProjected.z >= -1 && pointProjected.x <= 1 && pointProjected.x >= -1 &&
                     pointProjected.y <= 1 && pointProjected.y >= -1);
        if (normalizedTo01)
        {
            Matrix4x4 converter = CreateConvertionMatrixMinus11To01();
            pointProjected = converter *pointProjected; // same as MultiplyPoint3x4, ignore scaling
        }

        return pointProjected;
    }*/
    
float3 WorldToProjectedLocal(float3 p)
{
    float4 p4 = float4(p.xyz,1);
    return p4;
}

[numthreads(8,8,16)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    //Calculate Light influence on voxel (sample shadowmap?)
//    Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
    
    //RemoveLater?
    //Input[id] = float4(0,0.1,0.1,0.1);
    //uint index = flat(id);
    //float4 p = points[index];
    
    lightBufferTexture[id] = float4(0.1,0.1,0.1,0.05);//Ambient light
    lightBufferTexture[id] = float4(0,0,0,0);
    //for each light
    float4 pointWS = points[flat(id)];
    float4 pointProjected = mul(vp, pointWS);
    pointProjected = pointProjected/pointProjected.w;
    bool inside = (pointProjected.z <= 1 && pointProjected.z >= -1 && pointProjected.x <= 1 && pointProjected.x >= -1 &&
                         pointProjected.y <= 1 && pointProjected.y >= -1);
    
    pointProjected = mul(convertTo01,pointProjected);
    float depth = LightDepth.SampleLevel(samplerLightDepth,pointProjected.xy,0).r;
    //float depth = tex2D(samplerLightDepth, pointProjected.xy).r;
    float3 pointToLightRay = lightWS-pointWS;
    float pointToLightDistance = distance(pointWS.xyz,lightWS.xyz);
    float phase = 1/(4*M_PI);
    
    if(inside){
        if(1-depth < pointProjected.z)
        {
            
        }else{
            float4 old = lightBufferTexture[id];
            float3 color = old.rgb;
            float intensity =20;
            float3 newColor =float3(0,0.5,0.5);
            
            pointToLightDistance = sqrt(pointToLightDistance);
            
            //transmittance from optical depth
            float weight =  exp(-(pointToLightDistance));
            //weight = 1;
            intensity *= weight;
            //color += intensity*(newColor.rgb);
            //color = color/(intensity+old);
            //intensity = (intensity +old.a);
            color = saturate(intensity * newColor * phase);
            intensity = clamp(intensity,0,1);
            lightBufferTexture[id] = float4(color.rgb, intensity);//set light color and intensity
            //lightBufferTexture[id]  = float4(0.5,0.5,0.5,1);
        }
    }else
    {
        //lightBufferTexture[id] = float4(0,0,0,0);
    }
    //Result[id] = float4(depth,depth,depth,1);
    //Result[id] = LightDepth.SampleLevel(samplerLightDepth,pointProjected.xy,0).a;
    //points all 0!?!?
    //float4 t = float4(1 - points[flat(id)].xyz, 0.5);//+float4(1,1,1,0);
    //Result[id] = t;
    //Result[id] = float4(normalize(Input[id].xyz),0.5);
    //Result[id] = float4(id.x & id.y, (id.x & 15)/15.0, (id.z & 15)/15.0, 1.0);
    //Result[id] = LightDepth[id.xy];
}
