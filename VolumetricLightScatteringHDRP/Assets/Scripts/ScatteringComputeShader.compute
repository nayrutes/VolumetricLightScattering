// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture3D<float4> Input;
RWTexture3D<float4> Result;
uint VOLUME_DEPTH;
float4 insetValue;
float3 size;

//Beer-Lambert's Law?
//One Step
float4 AccumulateScattering(float4 colorAndDensityFront, float4 colorAndDensityBack)
{
    float3 light = colorAndDensityFront.rgb + saturate(exp(-colorAndDensityFront.a))*colorAndDensityBack.rgb;
    return float4(light.rgb, colorAndDensityFront.a + colorAndDensityBack.a);
}

//Write Out Final Scattering Value
void WriteOutput(in uint3 pos, in float4 colorAndDensity)
{
    float4 finalValue = float4(colorAndDensity.rgb, exp(-colorAndDensity.a));
    Result[pos].rgba = finalValue;
}

void Insert(){
    for (int xx = 0; xx < size.x; xx++) {
        for (int yy = 0; yy < size.y; yy++) {
            for (int zz = 0; zz < size.z; zz++) {
            Input[uint3(xx,yy,zz)] = insetValue;
            }
        }
    }
}

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    
    //override Input for testing
    //for(uint d = 0; d < VOLUME_DEPTH;d++)
    //{
        //float4 insetValue = float4(0.5,0.5,0.5,0.5);
    //    Input[uint3(id.xy,d)] = insetValue;
    //}
    Insert();
    
    //actual calculation
    for (uint x=0; x<size.x; x++){
        for (uint y=0; y<size.y; y++){
            float4 currentSliceValue = Input[uint3(x,y,0)].rgba;
            WriteOutput(uint3(x,y,0),currentSliceValue);
            
            for(uint z = 1; z < VOLUME_DEPTH;z++)
            {
                float4 nextValue = Input[uint3(x,y, z)].rgba;
                currentSliceValue = AccumulateScattering(currentSliceValue, nextValue);
                WriteOutput(uint3(x,y, z), currentSliceValue);
            }
        }
    }
    
    //Result[id.xyz] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
