// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture3D<float4> DensityBuffer;
RWTexture3D<float4> LightBuffer;
RWTexture3D<float4> Result;
Texture2D<float4> CamDepth;
SamplerState samplerCamDepth;
StructuredBuffer<float> depths;
uint VOLUME_DEPTH;
float4 insetValue;
float3 size;
float4 _ZBufferParams;

//Beer-Lambert's Law?
//One Step
float4 AccumulateScattering(float4 colorAndDensityFront, float4 colorAndDensityBack, in float depth)
{
    float densityFront = colorAndDensityFront.a;
    float densityBack = colorAndDensityBack.a ;
    float3 colorFront = colorAndDensityFront.rgb;
    float3 colorBack = colorAndDensityBack.rgb;
    
    float factorColorBack = max(0, min(1, exp(-densityFront)));//saturate
    float3 light = colorFront + factorColorBack*colorBack;
    return float4(light.rgb, (densityFront + densityBack));//*(1-depth));
    
    //float3 light = colorAndDensityFront.rgb + saturate(exp(-colorAndDensityFront.a))*colorAndDensityBack.rgb;
    //return float4(light.rgb, colorAndDensityFront.a + colorAndDensityBack.a);
}

//Write Out Final Scattering Value
void WriteOutput(in uint3 pos, in float4 colorAndDensity, in float depth)
{
    float density = colorAndDensity.a;
    float3 color = colorAndDensity.rgb;

    float4 finalValue = float4(color.rgb, exp(-density));
    Result[pos].rgba = finalValue;
}

void Insert(){
    for (int xx = 0; xx < size.x; xx++) {
        for (int yy = 0; yy < size.y; yy++) {
            for (int zz = 0; zz < size.z; zz++) {
            DensityBuffer[uint3(xx,yy,zz)] = insetValue;
            }
        }
    }
}

float3 EvaluateLight(float extinction, float intervalLength, float3 voxelCoordBuffer)
{
    float4 lightColor = LOAD_TEXTURE3D(LightBuffer, voxelCoordBuffer);
    //float4 lightColor = float4(0.5,0.5,0.5,1);
    //transmittance from optical depth
    float weight =  exp(-(extinction * intervalLength));
    //weight=1;
    float ligtIntensity = lightColor.a;
    return (weight * lightColor.rgb); //is it falloff?
}

[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{    
    //actual calculation
    /*for (uint x=0; x<size.x; x++){
        for (uint y=0; y<size.y; y++){
            float4 currentSliceValue = DensityBuffer[uint3(x,y,0)].rgba;
            WriteOutput(uint3(x,y,0),currentSliceValue);
            
            for(uint z = 1; z < VOLUME_DEPTH;z++)
            {
                uint zTmp = z;
                float4 nextValue = DensityBuffer[uint3(x,y, zTmp)].rgba;
                currentSliceValue = AccumulateScattering(currentSliceValue, nextValue);
                WriteOutput(uint3(x,y, zTmp), currentSliceValue);
            }
        }
    }*/
#if 0
    float depth = 0;
    float4 currentSliceValue = DensityBuffer[uint3(id.xy,0)].rgba;
    currentSliceValue = LightBuffer[uint3(id.xy,0)].rgba;
    WriteOutput(uint3(id.xy,0),currentSliceValue, depth);
    //float xn = ((float)id.x)/((float)size.x);
    //float yn = ((float)id.y)/((float)size.y);
    //float depthCam = CamDepth.SampleLevel(samplerCamDepth,float2(xn,yn),0).r;
    //float depthCamLin = Linear01Depth(depthCam, _ZBufferParams);
    
    
    for(uint z = 1; z < VOLUME_DEPTH;z++)
    {
        //Result[uint3(id.xy,z)].rgba = float4(depthCamLin,0,0,0.5);
        //float depthDelta = depths[z] - depths[z-1];
        uint zTmp = z;
        /*if((1.0-depthCamLin) > depths[z])
        {
            currentSliceValue = float4(0,0,0,0);
            WriteOutput(uint3(id.xy, zTmp), currentSliceValue, depthDelta);
            //Result[uint3(id.xy,z)].rgba = float4(0,0,0,1);
        }
        else*/
        {
        float depthDelta = 0;
            float4 nextValue = DensityBuffer[uint3(id.xy, zTmp)].rgba;
            nextValue = LightBuffer[uint3(id.xy,zTmp)].rgba;
            currentSliceValue = AccumulateScattering(currentSliceValue, nextValue, depthDelta);
            WriteOutput(uint3(id.xy, zTmp), currentSliceValue, depthDelta);
        }           
    }
 #else
    float sliceDepthNear = depths[0];
    float3 totalRadiance = 0;
    float  opticalDepth  = 0;
   /* 
    float xn = ((float)id.x)/((float)size.x);
    float yn = ((float)id.y)/((float)size.y);
    float depthCam = CamDepth.SampleLevel(samplerCamDepth,float2(xn,yn),0).r;
    float depthCamLin = Linear01Depth(depthCam, _ZBufferParams);
    bool sliceDeeperThanDepthTextue = false;
    */
    for(uint z = 1; z < VOLUME_DEPTH;z++)
    {
        float sliceDepthFar = depths[z]; //TODO insert non-linear here?
        float sliceDepthDelta = sliceDepthFar - sliceDepthNear;
        float sliceDepthDeltaWorld = sliceDepthDelta*100;//TODO 100 camera range?
        //float sliceDepthDelta = 0.0078125; // 1/128
        //sliceDepthDelta = 0.015625;// 1/64
        //sliceDepthDelta = 0.03125;// 1/32
        //float xn = ((float)id.x)/((float)size.x);
        //float yn = ((float)id.y)/((float)size.y);
        uint3 voxelCoordBuffer = uint3(id.x,id.y, z);
        float4 density = LOAD_TEXTURE3D(DensityBuffer, voxelCoordBuffer);

        float3 fogColor = density.rgb;
        float  extinction = density.a;
        
        float3 light = EvaluateLight(extinction, sliceDepthDelta, voxelCoordBuffer);
        float4 blendValue = float4(light,  extinction * sliceDepthDelta );//TODO split and rename currentOpticalDepth
        float transmittance = exp(-opticalDepth);
        float phase = 1;
        float3 probeRadiance = float3(0,0,0);
        totalRadiance += (transmittance * fogColor * (phase * blendValue.rgb + probeRadiance))*sliceDepthDeltaWorld;//TODO replace blendValue with light and delete phase, probeRadiance 
        opticalDepth += 0.5 * blendValue.a;
        //Result[voxelCoordBuffer] = float4(totalRadiance, opticalDepth);
        
        /*sliceDeeperThanDepthTextue = sliceDepthNear > depthCamLin;
        if(sliceDeeperThanDepthTextue)
        {
            Result[voxelCoordBuffer] = float4(0,0,0,0);
        }else*/
        {
            Result[voxelCoordBuffer] = float4(totalRadiance, opticalDepth);
        }
        //opticalDepth +=blendValue.a;
        opticalDepth += 0.5 * blendValue.a;
        sliceDepthNear = sliceDepthFar;
    }
 #endif
}
